<!doctype html>
<html class="default no-js">
<head>
	<meta charset="utf-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>serialization-generator</title>
	<meta name="description" content="">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<link rel="stylesheet" href="assets/css/main.css">
</head>
<body>
<header>
	<div class="tsd-page-toolbar">
		<div class="container">
			<div class="table-wrap">
				<div class="table-cell" id="tsd-search" data-index="assets/js/search.js" data-base=".">
					<div class="field">
						<label for="tsd-search-field" class="tsd-widget search no-caption">Search</label>
						<input id="tsd-search-field" type="text" />
					</div>
					<ul class="results">
						<li class="state loading">Preparing search index...</li>
						<li class="state failure">The search index is not available</li>
					</ul>
					<a href="index.html" class="title">serialization-generator</a>
				</div>
				<div class="table-cell" id="tsd-widgets">
					<div id="tsd-filter">
						<a href="#" class="tsd-widget options no-caption" data-toggle="options">Options</a>
						<div class="tsd-filter-group">
							<div class="tsd-select" id="tsd-filter-visibility">
								<span class="tsd-select-label">All</span>
								<ul class="tsd-select-list">
									<li data-value="public">Public</li>
									<li data-value="protected">Public/Protected</li>
									<li data-value="private" class="selected">All</li>
								</ul>
							</div>
							<input type="checkbox" id="tsd-filter-inherited" checked />
							<label class="tsd-widget" for="tsd-filter-inherited">Inherited</label>
							<input type="checkbox" id="tsd-filter-externals" checked />
							<label class="tsd-widget" for="tsd-filter-externals">Externals</label>
						</div>
					</div>
					<a href="#" class="tsd-widget menu no-caption" data-toggle="menu">Menu</a>
				</div>
			</div>
		</div>
	</div>
	<div class="tsd-page-title">
		<div class="container">
			<ul class="tsd-breadcrumb">
				<li>
					<a href="globals.html">Globals</a>
				</li>
			</ul>
			<h1>serialization-generator</h1>
		</div>
	</div>
</header>
<div class="container container-main">
	<div class="row">
		<div class="col-8 col-content">
			<div class="tsd-panel tsd-typography">
				<a href="#serialization-generator" id="serialization-generator" style="color: inherit; text-decoration: none;">
					<h1>serialization-generator</h1>
				</a>
				<blockquote>
					<p><strong>Please have a look at the <code>This package vs FlatBuffers / protobuf</code> section below before making yourself familiar with this library.</strong></p>
				</blockquote>
				<p>The main target of this package is to make the creation of serializers to transform JavaScript Values into binary and back
				as easy as possible and to keep the creation readable.</p>
				<p>To archive this goal this package provides multiple simple serializers which you can combine to create more complex
				versions which fit your needed data structures.</p>
				<!-- USEFILE: examples\simple-example.ts; str => str.replace('../src', 'serialization-generator') -->
				<pre><code class="language-ts"><span class="hljs-keyword">import</span> {
    ArraySerializer,
    EnumSerializer,
    ObjectSerializer,
    VectorSerializer,
    SwitchSerializer,

    ARRAY_BUFFER_SERIALIZER,
    STRING_SERIALIZER,

    FLOAT32_SERIALIZER,
    FLOAT64_SERIALIZER,

    INT8_SERIALIZER,
    INT16_SERIALIZER,
    INT32_SERIALIZER,

    UINT8_SERIALIZER,
    UINT16_SERIALIZER,
    UINT32_SERIALIZER
} <span class="hljs-keyword">from</span> <span class="hljs-string">'serialization-generator'</span>;

<span class="hljs-keyword">interface</span> ExampleSubType {
    d: <span class="hljs-built_in">number</span>;
    e: <span class="hljs-built_in">number</span>;
    f: <span class="hljs-built_in">ArrayBuffer</span>;
}

<span class="hljs-keyword">type</span> Enum = <span class="hljs-string">'ENUM_VAL_A'</span> | <span class="hljs-string">'ENUM_VAL_B'</span> | <span class="hljs-string">'ENUM_VAL_C'</span>;

<span class="hljs-keyword">interface</span> ExampleType {
    a: <span class="hljs-built_in">number</span>;
    b: <span class="hljs-built_in">number</span>;
    c: ExampleSubType;
    g: <span class="hljs-built_in">string</span>;
    h: <span class="hljs-built_in">number</span>[];
    i: [<span class="hljs-built_in">number</span>, <span class="hljs-built_in">number</span>, <span class="hljs-built_in">number</span>, <span class="hljs-built_in">number</span>];
    j: Enum;
}

<span class="hljs-comment">// you can define the object serializer either directly at construction</span>

<span class="hljs-keyword">const</span> EXAMPLE_SUBTYPE_SERIALIZER = <span class="hljs-keyword">new</span> ObjectSerializer&lt;ExampleSubType&gt;({
    d: INT8_SERIALIZER,
    e: UINT16_SERIALIZER,
    f: ARRAY_BUFFER_SERIALIZER
});

<span class="hljs-comment">// or after with the append method</span>

<span class="hljs-keyword">const</span> exSer = <span class="hljs-keyword">new</span> ObjectSerializer&lt;ExampleType&gt;()
    .append(<span class="hljs-string">"a"</span>, UINT32_SERIALIZER)
    .append(<span class="hljs-string">"b"</span>, FLOAT32_SERIALIZER)
    .append(<span class="hljs-string">"c"</span>, EXAMPLE_SUBTYPE_SERIALIZER)
    .append(<span class="hljs-string">"g"</span>, STRING_SERIALIZER)
    .append(<span class="hljs-string">"h"</span>, <span class="hljs-keyword">new</span> ArraySerializer(UINT32_SERIALIZER))
    .append(<span class="hljs-string">"i"</span>, <span class="hljs-keyword">new</span> VectorSerializer(UINT8_SERIALIZER, <span class="hljs-number">4</span>))
    .append(<span class="hljs-string">"j"</span>, <span class="hljs-keyword">new</span> EnumSerializer&lt;Enum&gt;([<span class="hljs-string">'ENUM_VAL_A'</span>, <span class="hljs-string">'ENUM_VAL_B'</span>, <span class="hljs-string">'ENUM_VAL_C'</span>]))

<span class="hljs-keyword">const</span> ab = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ArrayBuffer</span>(<span class="hljs-number">3</span>);
<span class="hljs-keyword">new</span> <span class="hljs-built_in">Uint8Array</span>(ab).set([<span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">9</span>]);

<span class="hljs-keyword">const</span> instance: ExampleType = {
    a: <span class="hljs-number">12</span>,
    b: <span class="hljs-built_in">Math</span>.PI,
    c: {
        d: <span class="hljs-number">-22</span>,
        e: <span class="hljs-number">443</span>,
        f: ab
    },
    g: <span class="hljs-string">"Example string with UTF-8 chars â‚¬"</span>,
    h: [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">22</span>],
    i: [<span class="hljs-number">8</span>, <span class="hljs-number">7</span>, <span class="hljs-number">7</span>, <span class="hljs-number">2</span>],
    j: <span class="hljs-string">"ENUM_VAL_B"</span>
}

<span class="hljs-comment">// check whether the provided values are serializable by the configured serializer</span>
exSer.typeCheck(instance);

<span class="hljs-comment">// retrieve the number of bytes needed to serialize this value</span>
<span class="hljs-keyword">const</span> length = exSer.getSizeForValue(instance);
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'length'</span>, length);

<span class="hljs-comment">// create the arraybuffer to serialize this value</span>
<span class="hljs-keyword">const</span> data = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ArrayBuffer</span>(length);
<span class="hljs-keyword">const</span> view = <span class="hljs-keyword">new</span> <span class="hljs-built_in">DataView</span>(data);

exSer.serialize(view, <span class="hljs-number">0</span>, instance);
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'data'</span>, data);

<span class="hljs-keyword">const</span> deValue = exSer.deserialize(view, <span class="hljs-number">0</span>);
<span class="hljs-keyword">const</span> val = deValue.val;
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'val'</span>, val);</code></pre>
				<p><em>You can find this in <code>examples\simple-example.ts</code></em></p>
				<p>The provided functions are fully typesafe.</p>
				<a href="#usage" id="usage" style="color: inherit; text-decoration: none;">
					<h2>Usage</h2>
				</a>
				<p>The easiest way to use this package is by declaring your data structure by a TypeScript interface and then create the
					<code>ObjectSerializer</code> as was done in the example above. After this configuration you can export the serializer as reuse it
				in your code base. Other serializers can use this custom serializer as subserializers.</p>
				<p>Please have a look at the <a href="https://feirell.github.io/serialization-generator/">API documentation</a>.</p>
				<a href="#mapping--transforming-serializer" id="mapping--transforming-serializer" style="color: inherit; text-decoration: none;">
					<h2>Mapping / transforming serializer</h2>
				</a>
				<p>If want to implement a mapping serializer which, for example, maps an enum to a number and back you could do so in four ways.
				<code>EnumSerializer</code> is a specific class to map a static number of values to their indexes and back, primarily Enums.</p>
				<!-- USEFILE: examples\transform-values.ts; str => str.replace('../src', 'serialization-generator') -->
				<pre><code class="language-ts"><span class="hljs-keyword">import</span> {
    createTransformSerializer,
    TransformSerializer,
    ValueSerializer,
    EnumSerializer,
    UINT8_SERIALIZER
} <span class="hljs-keyword">from</span> <span class="hljs-string">"serialization-generator"</span>;

<span class="hljs-keyword">type</span> OriginType = <span class="hljs-string">'ENUM_A'</span> | <span class="hljs-string">'ENUM_B'</span> | <span class="hljs-string">'ENUM_C'</span> | <span class="hljs-string">'ENUM_D'</span>;
<span class="hljs-keyword">type</span> BaseType = <span class="hljs-number">0</span> | <span class="hljs-number">1</span> | <span class="hljs-number">2</span> | <span class="hljs-number">3</span>;

<span class="hljs-keyword">const</span> fromOriginToBase = (val: OriginType): <span class="hljs-function"><span class="hljs-params">BaseType</span> =&gt;</span> {
    <span class="hljs-keyword">switch</span> (val) {
        <span class="hljs-keyword">case</span> <span class="hljs-string">"ENUM_A"</span>: <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
        <span class="hljs-keyword">case</span> <span class="hljs-string">"ENUM_B"</span>: <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
        <span class="hljs-keyword">case</span> <span class="hljs-string">"ENUM_C"</span>: <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;
        <span class="hljs-keyword">case</span> <span class="hljs-string">"ENUM_D"</span>: <span class="hljs-keyword">return</span> <span class="hljs-number">3</span>;
        <span class="hljs-keyword">default</span>: <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"this OriginType is invalid "</span> + val);
    }
}

<span class="hljs-keyword">const</span> fromBaseToOrigin = (val: BaseType): <span class="hljs-function"><span class="hljs-params">OriginType</span> =&gt;</span> {
    <span class="hljs-keyword">switch</span> (val) {
        <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>: <span class="hljs-keyword">return</span> <span class="hljs-string">"ENUM_A"</span>;
        <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>: <span class="hljs-keyword">return</span> <span class="hljs-string">"ENUM_B"</span>;
        <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>: <span class="hljs-keyword">return</span> <span class="hljs-string">"ENUM_C"</span>;
        <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>: <span class="hljs-keyword">return</span> <span class="hljs-string">"ENUM_D"</span>;
        <span class="hljs-keyword">default</span>: <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"this BaseType is invalid "</span> + val);
    }
}

<span class="hljs-keyword">const</span> isOriginType = (val: <span class="hljs-built_in">any</span>): val is OriginType =&gt;
    val != <span class="hljs-string">"ENUM_A"</span> &amp;&amp;
    val != <span class="hljs-string">"ENUM_B"</span> &amp;&amp;
    val != <span class="hljs-string">"ENUM_C"</span> &amp;&amp;
    val != <span class="hljs-string">"ENUM_D"</span>;

<span class="hljs-comment">// When the number of values of type Origin are static</span>
<span class="hljs-comment">// and finite you can use the EnumSerializer</span>

<span class="hljs-keyword">const</span> possibleValues: OriginType[] = [<span class="hljs-string">'ENUM_A'</span>, <span class="hljs-string">'ENUM_B'</span>, <span class="hljs-string">'ENUM_C'</span>, <span class="hljs-string">'ENUM_D'</span>];
<span class="hljs-keyword">const</span> instance = <span class="hljs-keyword">new</span> EnumSerializer(possibleValues);

<span class="hljs-comment">// If this is not the case then you have four other options</span>

<span class="hljs-comment">// First Option: Custom Class</span>

<span class="hljs-keyword">class</span> OriginTypeSerializerCustom <span class="hljs-keyword">extends</span> ValueSerializer&lt;OriginType&gt; {
    getStaticSize(): <span class="hljs-built_in">number</span> | <span class="hljs-literal">undefined</span> {
        <span class="hljs-keyword">return</span> UINT8_SERIALIZER.getStaticSize();
    }

    getSizeForValue(val: OriginType): <span class="hljs-built_in">number</span> {
        <span class="hljs-keyword">return</span> UINT8_SERIALIZER.getSizeForValue(fromOriginToBase(val));
    }

    serialize(dv: <span class="hljs-built_in">DataView</span>, offset: <span class="hljs-built_in">number</span>, val: OriginType): { offset: <span class="hljs-built_in">number</span> } {
        <span class="hljs-keyword">return</span> UINT8_SERIALIZER.serialize(dv, offset, fromOriginToBase(val));
    }

    deserialize(dv: <span class="hljs-built_in">DataView</span>, offset: <span class="hljs-built_in">number</span>): { offset: <span class="hljs-built_in">number</span>; val: OriginType } {
        <span class="hljs-keyword">const</span> ret = UINT8_SERIALIZER.deserialize(dv, offset);
        <span class="hljs-keyword">return</span> {
            offset: ret.offset,
            val: fromBaseToOrigin(ret.val <span class="hljs-keyword">as</span> BaseType)
        }
    }

    typeCheck(val: OriginType, name: <span class="hljs-built_in">string</span> = <span class="hljs-string">'val'</span>): <span class="hljs-built_in">void</span> {
        <span class="hljs-keyword">if</span> (!isOriginType(val))
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(name + <span class="hljs-string">" needs to be of type OriginType"</span>);

        UINT8_SERIALIZER.typeCheck(fromOriginToBase(val), name);
    }

}

<span class="hljs-comment">// Second Option: using the TransformSerializer Class</span>

<span class="hljs-keyword">class</span> OriginTypeSerializerTransformSerializer <span class="hljs-keyword">extends</span> TransformSerializer&lt;OriginType, BaseType&gt; {
    fromBaseToOrigin(val: BaseType): OriginType {
        <span class="hljs-keyword">return</span> fromBaseToOrigin(val);
    }

    fromOriginToBase(val: OriginType): BaseType {
        <span class="hljs-keyword">return</span> fromOriginToBase(val);
    }

    originTypeCheck(val: OriginType, name: <span class="hljs-built_in">string</span>): <span class="hljs-built_in">void</span> {
        <span class="hljs-keyword">if</span> (!isOriginType(val))
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(name + <span class="hljs-string">" needs to be of type OriginType"</span>);
    }
}

<span class="hljs-comment">// Third Option: creating the TransformSerializer via function</span>

<span class="hljs-keyword">const</span> ORIGIN_TYPE_SERIALIZER_VIA_FNC = createTransformSerializer(
    fromOriginToBase,
    fromBaseToOrigin,
    UINT8_SERIALIZER <span class="hljs-keyword">as</span> ValueSerializer&lt;BaseType&gt;,
    <span class="hljs-function">(<span class="hljs-params">val, name</span>) =&gt;</span> {
        <span class="hljs-keyword">if</span> (!isOriginType(val))
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(name + <span class="hljs-string">" needs to be of type OriginType"</span>);
    }
);

<span class="hljs-comment">// Fourth Option: transform the type to serializable beforehand</span>
</code></pre>
				<p><em>You can find this in <code>examples\transform-values.ts</code></em></p>
				<a href="#joined-structures" id="joined-structures" style="color: inherit; text-decoration: none;">
					<h2>Joined structures</h2>
				</a>
				<p>If you have a object structure which is composed of multiple separate structures and they are identified by a property
				then you can use the <code>SwitchSerializer</code>.</p>
				<!-- USEFILE: examples\switch-serializer.ts; str => str.replace('../src', 'serialization-generator') -->
				<pre><code class="language-ts"><span class="hljs-keyword">import</span> {
    ObjectSerializer,
    SwitchSerializer,

    INT32_SERIALIZER,
    STRING_SERIALIZER
} <span class="hljs-keyword">from</span> <span class="hljs-string">"serialization-generator"</span>;

<span class="hljs-keyword">interface</span> JoinedTypeA {
    <span class="hljs-keyword">type</span>: <span class="hljs-string">'a'</span>;
    l: <span class="hljs-built_in">number</span>;
}

<span class="hljs-keyword">interface</span> JoinedTypeB {
    <span class="hljs-keyword">type</span>: <span class="hljs-string">'b'</span>;
    m: <span class="hljs-built_in">string</span>;
}

<span class="hljs-comment">// if you have a joined type which has a property which distinguishes between different</span>
<span class="hljs-comment">// type then you can use the SwitchSerializer to serialize / deserialize the value</span>
<span class="hljs-keyword">type</span> JoinedType = JoinedTypeA | JoinedTypeB;

<span class="hljs-comment">// To use the Switch Serializer you need to construct the serializer for the different sub</span>
<span class="hljs-comment">// types Those serializers SHOULD NOT contain a serializer for the property which is used</span>
<span class="hljs-comment">// to distinguish them since this property will be handled by the switch serializer</span>
<span class="hljs-keyword">const</span> JOINED_TYPE_A = <span class="hljs-keyword">new</span> ObjectSerializer&lt;JoinedTypeA&gt;({l: INT32_SERIALIZER});
<span class="hljs-keyword">const</span> JOINED_TYPE_B = <span class="hljs-keyword">new</span> ObjectSerializer&lt;JoinedTypeB&gt;({m: STRING_SERIALIZER});

<span class="hljs-comment">// When you have a serializer for all subtypes you can combine them to a SwitchSerializer.</span>
<span class="hljs-comment">// Be aware that there is not type check whether the provided serializer fits for the</span>
<span class="hljs-comment">// structure identified by the identifier. You need to call the finalize after all</span>
<span class="hljs-comment">// register calls are done to be able to use this serializer.</span>
<span class="hljs-keyword">const</span> JOINED_TYPE_SERIALIZER = <span class="hljs-keyword">new</span> SwitchSerializer&lt;JoinedType, <span class="hljs-string">'type'</span>&gt;(<span class="hljs-string">'type'</span>)
    .register(<span class="hljs-string">"a"</span>, JOINED_TYPE_A)
    .register(<span class="hljs-string">"b"</span>, JOINED_TYPE_B)
    .finalize();</code></pre>
				<p><em>You can find this in <code>examples\switch-serializer.ts</code></em></p>
				<a href="#performance-remarks" id="performance-remarks" style="color: inherit; text-decoration: none;">
					<h2>Performance remarks</h2>
				</a>
				<p>This package tries to make the serialization as fast as possible and still keep a readable API.</p>
				<p>There will be no typecheck done on serialization, if you can not trust the datastructure you can do one manually by calling
				<code>typeCheck</code> of the serializer.</p>
				<p>The provided default serializers have different runtime behavior which can heavily influence your choice for the datastructure.</p>
				<p>The performance report below is the result of the serialization from a similar datasctructure like the one shown above.
					<code>serialization</code> includes the <code>ObjectSerializer</code> and the number serializer but nothing else,
				all other are added separately.</p>
				<p>The string serializer uses an internal cache on serialize, which results in a skewed result.</p>
				<pre><code>                ops/sec  MoE samples relative
serialization
  serialize   <span class="hljs-number">2</span>,<span class="hljs-number">620</span>,<span class="hljs-number">854</span> <span class="hljs-number">1.81</span>      <span class="hljs-number">88</span>     <span class="hljs-number">1.20</span>
  deserialize <span class="hljs-number">2</span>,<span class="hljs-number">178</span>,<span class="hljs-number">406</span> <span class="hljs-number">1.64</span>      <span class="hljs-number">89</span>     <span class="hljs-number">1.00</span>
serialization + Array
  serialize   <span class="hljs-number">1</span>,<span class="hljs-number">287</span>,<span class="hljs-number">073</span> <span class="hljs-number">2.51</span>      <span class="hljs-number">85</span>     <span class="hljs-number">1.29</span>
  deserialize <span class="hljs-number">1</span>,<span class="hljs-number">000</span>,<span class="hljs-number">358</span> <span class="hljs-number">5.47</span>      <span class="hljs-number">79</span>     <span class="hljs-number">1.00</span>
serialization + Vector
  serialize   <span class="hljs-number">1</span>,<span class="hljs-number">100</span>,<span class="hljs-number">311</span> <span class="hljs-number">2.72</span>      <span class="hljs-number">86</span>     <span class="hljs-number">1.23</span>
  deserialize   <span class="hljs-number">895</span>,<span class="hljs-number">438</span> <span class="hljs-number">2.93</span>      <span class="hljs-number">86</span>     <span class="hljs-number">1.00</span>
serialization + AB
  serialize   <span class="hljs-number">1</span>,<span class="hljs-number">269</span>,<span class="hljs-number">839</span> <span class="hljs-number">3.07</span>      <span class="hljs-number">86</span>     <span class="hljs-number">3.04</span>
  deserialize   <span class="hljs-number">417</span>,<span class="hljs-number">772</span> <span class="hljs-number">2.08</span>      <span class="hljs-number">86</span>     <span class="hljs-number">1.00</span>
serialization + String
  serialize   <span class="hljs-number">1</span>,<span class="hljs-number">184</span>,<span class="hljs-number">358</span> <span class="hljs-number">1.74</span>      <span class="hljs-number">89</span>     <span class="hljs-number">6.11</span>
  deserialize   <span class="hljs-number">193</span>,<span class="hljs-number">857</span> <span class="hljs-number">2.73</span>      <span class="hljs-number">86</span>     <span class="hljs-number">1.00</span>
serialization + Enum
  serialize   <span class="hljs-number">1</span>,<span class="hljs-number">697</span>,<span class="hljs-number">583</span> <span class="hljs-number">0.76</span>      <span class="hljs-number">93</span>     <span class="hljs-number">1.29</span>
  deserialize <span class="hljs-number">1</span>,<span class="hljs-number">312</span>,<span class="hljs-number">046</span> <span class="hljs-number">1.49</span>      <span class="hljs-number">84</span>     <span class="hljs-number">1.00</span>
serialization + Array + Vector + AB + String + Enum
  serialize     <span class="hljs-number">440</span>,<span class="hljs-number">456</span> <span class="hljs-number">0.66</span>      <span class="hljs-number">95</span>     <span class="hljs-number">3.30</span>
  deserialize   <span class="hljs-number">133</span>,<span class="hljs-number">296</span> <span class="hljs-number">1.04</span>      <span class="hljs-number">89</span>     <span class="hljs-number">1.00</span></code></pre><p>As this performance measurement show array buffer and string serialization are quite slow, I would recommend therefore
				to stick to the other serializers. The most efficient option is to only use <code>ObjectSerializer</code> and the number serializer.  </p>
				<a href="#in-comparison-to-other-means-of-serialization" id="in-comparison-to-other-means-of-serialization" style="color: inherit; text-decoration: none;">
					<h2>In comparison to other means of serialization</h2>
				</a>
				<p>This package is rather basic and is only meant to serialize structures which remain mostly static.</p>
				<a href="#this-package-vs-json" id="this-package-vs-json" style="color: inherit; text-decoration: none;">
					<h3>This package vs JSON</h3>
				</a>
				<p>+ Maps to a lot less bytes</p>
				<p>+ Has type check</p>
				<p>+ The structure does not need to be send / saved each time</p>
				<p>- Needs to be prepared</p>
				<p>- The structure needs to remain the same</p>
				<p>- The receiver needs to know the structure and construct a deserializer</p>
				<a href="#this-package-vs-flatbuffers--protobuf" id="this-package-vs-flatbuffers--protobuf" style="color: inherit; text-decoration: none;">
					<h3>This package vs FlatBuffers / protobuf</h3>
				</a>
				<p><a href="https://google.github.io/flatbuffers">FlatBuffers</a> and <a href="https://protobufjs.github.io/protobuf.js/">protobuf</a> are two solutions which are well tested and have a huge userbase.
				I had not found those before implementing this library. They might be better suited for your usecase!</p>
				<p>Disclaimer: I have never used one of them, my pros and cons are only first impressions. </p>
				<p>+ Only meant to transport JavaScript Values, might be more suitable</p>
				<p>+ This library is only meant to be used by JavaScript or TypeScript, might be more tailored for that usecase</p>
				<p>- They are better tested</p>
				<p>- The other libraries have an extensive documentations / many answered questions</p>
				<p>- Might have an inferior performance, might be better optimized</p>
				<p>- Somewhat standard</p>
				<p>- You can access data from FlatBuffers without deserialization</p>
				<a href="#structured-clone" id="structured-clone" style="color: inherit; text-decoration: none;">
					<h3>Structured clone</h3>
				</a>
				<p>This is internally used by the JavaScript engine to transfer JavaScript values from one realm to another (WebWorkers, IndexDB, History API).
				Sadly this API is not yet exposed directly but might be in the future.  </p>
				<p>NodeJS exposed this functionality from the V8, have look here: <a href="https://nodejs.org/api/v8.html#v8_serialization_api">https://nodejs.org/api/v8.html#v8_serialization_api</a></p>
				<p>Either way those values can not be read by JavaScript in the browser, which makes it not suitable for my usecase.
				Hopefully this functionality will come to the browser at some point, you can read more about it here:</p>
				<p>Definition: <a href="https://html.spec.whatwg.org/multipage/structured-data.html#structuredserializeforstorage">https://html.spec.whatwg.org/multipage/structured-data.html#structuredserializeforstorage</a>
					ECMAScript proposal: <a href="https://github.com/dslomov/ecmascript-structured-clone">https://github.com/dslomov/ecmascript-structured-clone</a> (found here: <a href="https://github.com/tc39/proposals/blob/master/stage-0-proposals.md">https://github.com/tc39/proposals/blob/master/stage-0-proposals.md</a>)
				Discussion about specification: <a href="https://github.com/whatwg/html/issues/793">https://github.com/whatwg/html/issues/793</a></p>
				<a href="#runtime-requirements" id="runtime-requirements" style="color: inherit; text-decoration: none;">
					<h2>Runtime requirements</h2>
				</a>
				<p>This package heavily relies on <code>ArrayBuffer</code> and <code>DataView</code>. This package will not work if they are not present. </p>
			</div>
		</div>
		<div class="col-4 col-menu menu-sticky-wrap menu-highlight">
			<nav class="tsd-navigation primary">
				<ul>
					<li class="globals  ">
						<a href="globals.html"><em>Globals</em></a>
					</li>
				</ul>
			</nav>
			<nav class="tsd-navigation secondary menu-sticky">
				<ul class="before-current">
					<li class=" tsd-kind-class">
						<a href="classes/arraybufferserializer.html" class="tsd-kind-icon">Array<wbr>Buffer<wbr>Serializer</a>
					</li>
					<li class=" tsd-kind-class tsd-has-type-parameter">
						<a href="classes/arrayserializer.html" class="tsd-kind-icon">Array<wbr>Serializer</a>
					</li>
					<li class=" tsd-kind-class tsd-has-type-parameter">
						<a href="classes/enumserializer.html" class="tsd-kind-icon">Enum<wbr>Serializer</a>
					</li>
					<li class=" tsd-kind-class tsd-has-type-parameter">
						<a href="classes/objectserializer.html" class="tsd-kind-icon">Object<wbr>Serializer</a>
					</li>
					<li class=" tsd-kind-class tsd-has-type-parameter">
						<a href="classes/stringserializer.html" class="tsd-kind-icon">String<wbr>Serializer</a>
					</li>
					<li class=" tsd-kind-class tsd-has-type-parameter">
						<a href="classes/switchserializer.html" class="tsd-kind-icon">Switch<wbr>Serializer</a>
					</li>
					<li class=" tsd-kind-class tsd-has-type-parameter">
						<a href="classes/transformserializer.html" class="tsd-kind-icon">Transform<wbr>Serializer</a>
					</li>
					<li class=" tsd-kind-class tsd-has-type-parameter">
						<a href="classes/valueserializer.html" class="tsd-kind-icon">Value<wbr>Serializer</a>
					</li>
					<li class=" tsd-kind-class tsd-has-type-parameter">
						<a href="classes/vectorserializer.html" class="tsd-kind-icon">Vector<wbr>Serializer</a>
					</li>
					<li class=" tsd-kind-variable">
						<a href="globals.html#array_buffer_serializer" class="tsd-kind-icon">ARRAY_<wbr>BUFFER_<wbr>SERIALIZER</a>
					</li>
					<li class=" tsd-kind-variable">
						<a href="globals.html#float32_serializer" class="tsd-kind-icon">FLOAT32_<wbr>SERIALIZER</a>
					</li>
					<li class=" tsd-kind-variable">
						<a href="globals.html#float64_serializer" class="tsd-kind-icon">FLOAT64_<wbr>SERIALIZER</a>
					</li>
					<li class=" tsd-kind-variable">
						<a href="globals.html#int16_serializer" class="tsd-kind-icon">INT16_<wbr>SERIALIZER</a>
					</li>
					<li class=" tsd-kind-variable">
						<a href="globals.html#int32_serializer" class="tsd-kind-icon">INT32_<wbr>SERIALIZER</a>
					</li>
					<li class=" tsd-kind-variable">
						<a href="globals.html#int8_serializer" class="tsd-kind-icon">INT8_<wbr>SERIALIZER</a>
					</li>
					<li class=" tsd-kind-variable">
						<a href="globals.html#string_serializer" class="tsd-kind-icon">STRING_<wbr>SERIALIZER</a>
					</li>
					<li class=" tsd-kind-variable">
						<a href="globals.html#uint16_serializer" class="tsd-kind-icon">UINT16_<wbr>SERIALIZER</a>
					</li>
					<li class=" tsd-kind-variable">
						<a href="globals.html#uint32_serializer" class="tsd-kind-icon">UINT32_<wbr>SERIALIZER</a>
					</li>
					<li class=" tsd-kind-variable">
						<a href="globals.html#uint8_serializer" class="tsd-kind-icon">UINT8_<wbr>SERIALIZER</a>
					</li>
					<li class=" tsd-kind-function tsd-has-type-parameter">
						<a href="globals.html#createtransformserializer" class="tsd-kind-icon">create<wbr>Transform<wbr>Serializer</a>
					</li>
				</ul>
			</nav>
		</div>
	</div>
</div>
<footer class="with-border-bottom">
	<div class="container">
		<h2>Legend</h2>
		<div class="tsd-legend-group">
			<ul class="tsd-legend">
				<li class="tsd-kind-module"><span class="tsd-kind-icon">Module</span></li>
				<li class="tsd-kind-object-literal"><span class="tsd-kind-icon">Object literal</span></li>
				<li class="tsd-kind-variable"><span class="tsd-kind-icon">Variable</span></li>
				<li class="tsd-kind-function"><span class="tsd-kind-icon">Function</span></li>
				<li class="tsd-kind-function tsd-has-type-parameter"><span class="tsd-kind-icon">Function with type parameter</span></li>
				<li class="tsd-kind-index-signature"><span class="tsd-kind-icon">Index signature</span></li>
				<li class="tsd-kind-type-alias"><span class="tsd-kind-icon">Type alias</span></li>
				<li class="tsd-kind-type-alias tsd-has-type-parameter"><span class="tsd-kind-icon">Type alias with type parameter</span></li>
			</ul>
			<ul class="tsd-legend">
				<li class="tsd-kind-enum"><span class="tsd-kind-icon">Enumeration</span></li>
				<li class="tsd-kind-enum-member"><span class="tsd-kind-icon">Enumeration member</span></li>
				<li class="tsd-kind-property tsd-parent-kind-enum"><span class="tsd-kind-icon">Property</span></li>
				<li class="tsd-kind-method tsd-parent-kind-enum"><span class="tsd-kind-icon">Method</span></li>
			</ul>
			<ul class="tsd-legend">
				<li class="tsd-kind-interface"><span class="tsd-kind-icon">Interface</span></li>
				<li class="tsd-kind-interface tsd-has-type-parameter"><span class="tsd-kind-icon">Interface with type parameter</span></li>
				<li class="tsd-kind-constructor tsd-parent-kind-interface"><span class="tsd-kind-icon">Constructor</span></li>
				<li class="tsd-kind-property tsd-parent-kind-interface"><span class="tsd-kind-icon">Property</span></li>
				<li class="tsd-kind-method tsd-parent-kind-interface"><span class="tsd-kind-icon">Method</span></li>
				<li class="tsd-kind-index-signature tsd-parent-kind-interface"><span class="tsd-kind-icon">Index signature</span></li>
			</ul>
			<ul class="tsd-legend">
				<li class="tsd-kind-class"><span class="tsd-kind-icon">Class</span></li>
				<li class="tsd-kind-class tsd-has-type-parameter"><span class="tsd-kind-icon">Class with type parameter</span></li>
				<li class="tsd-kind-constructor tsd-parent-kind-class"><span class="tsd-kind-icon">Constructor</span></li>
				<li class="tsd-kind-property tsd-parent-kind-class"><span class="tsd-kind-icon">Property</span></li>
				<li class="tsd-kind-method tsd-parent-kind-class"><span class="tsd-kind-icon">Method</span></li>
				<li class="tsd-kind-accessor tsd-parent-kind-class"><span class="tsd-kind-icon">Accessor</span></li>
				<li class="tsd-kind-index-signature tsd-parent-kind-class"><span class="tsd-kind-icon">Index signature</span></li>
			</ul>
			<ul class="tsd-legend">
				<li class="tsd-kind-constructor tsd-parent-kind-class tsd-is-inherited"><span class="tsd-kind-icon">Inherited constructor</span></li>
				<li class="tsd-kind-property tsd-parent-kind-class tsd-is-inherited"><span class="tsd-kind-icon">Inherited property</span></li>
				<li class="tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><span class="tsd-kind-icon">Inherited method</span></li>
				<li class="tsd-kind-accessor tsd-parent-kind-class tsd-is-inherited"><span class="tsd-kind-icon">Inherited accessor</span></li>
			</ul>
			<ul class="tsd-legend">
				<li class="tsd-kind-property tsd-parent-kind-class tsd-is-protected"><span class="tsd-kind-icon">Protected property</span></li>
				<li class="tsd-kind-method tsd-parent-kind-class tsd-is-protected"><span class="tsd-kind-icon">Protected method</span></li>
				<li class="tsd-kind-accessor tsd-parent-kind-class tsd-is-protected"><span class="tsd-kind-icon">Protected accessor</span></li>
			</ul>
			<ul class="tsd-legend">
				<li class="tsd-kind-property tsd-parent-kind-class tsd-is-private"><span class="tsd-kind-icon">Private property</span></li>
				<li class="tsd-kind-method tsd-parent-kind-class tsd-is-private"><span class="tsd-kind-icon">Private method</span></li>
				<li class="tsd-kind-accessor tsd-parent-kind-class tsd-is-private"><span class="tsd-kind-icon">Private accessor</span></li>
			</ul>
			<ul class="tsd-legend">
				<li class="tsd-kind-property tsd-parent-kind-class tsd-is-static"><span class="tsd-kind-icon">Static property</span></li>
				<li class="tsd-kind-call-signature tsd-parent-kind-class tsd-is-static"><span class="tsd-kind-icon">Static method</span></li>
			</ul>
		</div>
	</div>
</footer>
<div class="container tsd-generator">
	<p>Generated using <a href="https://typedoc.org/" target="_blank">TypeDoc</a></p>
</div>
<div class="overlay"></div>
<script src="assets/js/main.js"></script>
<script>if (location.protocol == 'file:') document.write('<script src="assets/js/search.js"><' + '/script>');</script>
</body>
</html>